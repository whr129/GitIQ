{"text": "window.onload = function() {\n    var gameTitle = document.getElementById(\"game-title\");\n    gameTitle.onclick = function() {\n        var menu = document.getElementById(\"popup-menu\");\n        menu.classList.toggle(\"hidden\");\n    };\n};\n", "metadata": {"path": "script.js", "size": "234", "chunk_range": "0:234"}}
{"text": "document.addEventListener('DOMContentLoaded', () => {\n    initializeGameBoard(10, 15, 1); // 10*15 grid\n});\n\nlet gameState = {\n    rows: 0,\n    cols: 0,\n    n: 0,\n    count1: 0, // Correctly flagged mines\n    count2: 0, // Revealed non-mine cells\n};\n\n// initialize the game board\nfunction initializeGameBoard(rows, cols, numberOfMines) {\n    gameState.rows = rows;\n    gameState.cols = cols;\n    gameState.n = numberOfMines;\n    gameState.count1 = 0;\n    gameState.count2 = 0;\n\n    const grid = docum", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "0:500"}}
{"text": "State.n = numberOfMines;\n    gameState.count1 = 0;\n    gameState.count2 = 0;\n\n    const grid = document.getElementById('gameBoard');\n    // clear the grid if you want to reinitialize it\n    grid.innerHTML = '';\n    grid.style.gridTemplateColumns = `repeat(${cols}, 35px)`; // Set the number of columns based on the grid size\n\n\n    // generate a map marking the position of mines\n    const minePositions = generateMinePositions(rows, cols, numberOfMines);\n\n    for (let i = 0; i < rows * cols; i++) {\n", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "400:900"}}
{"text": "ns = generateMinePositions(rows, cols, numberOfMines);\n\n    for (let i = 0; i < rows * cols; i++) {\n        let cell = document.createElement('div');\n        cell.classList.add('cell');\n        \n        // add the row and col # of each cell as a data attributes to that cell\n        const row = Math.floor(i / cols);  // in the range of [0, row - 1]\n        const col = i % cols;              // in the range of [0, col - 1]\n        cell.dataset.row = row;\n        cell.dataset.col = col;\n        cel", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "800:1300"}}
{"text": "he range of [0, col - 1]\n        cell.dataset.row = row;\n        cell.dataset.col = col;\n        cell.dataset.revealed = 'false';\n\n        // Use a boolean to indicate if the cell is a mine\n        const isMine = minePositions.has(`${row},${col}`);\n        cell.dataset.isMine = isMine; // Store the state directly in the cell's dataset\n\n        cell.addEventListener('click', function() {\n            handleCellClick(cell, minePositions, rows, cols);\n        });\n\n        cell.addEventListener('cont", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "1200:1700"}}
{"text": "  handleCellClick(cell, minePositions, rows, cols);\n        });\n\n        cell.addEventListener('contextmenu', function(event) {\n            event.preventDefault(); // Prevent the context menu from showing\n            handleRightClick(cell);\n        });\n\n        grid.appendChild(cell);\n    }\n}\n\n// generate mines in random position when initializing the game board\nfunction generateMinePositions(rows, cols, numberOfMines) {\n    let positions = new Set();\n\n    while (positions.size < numberOfMines) ", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "1600:2100"}}
{"text": ", cols, numberOfMines) {\n    let positions = new Set();\n\n    while (positions.size < numberOfMines) {\n        const row = Math.floor(Math.random() * rows);\n        const col = Math.floor(Math.random() * cols);\n        positions.add(`${row},${col}`); // Use a string like \"row,col\" to represent the position\n    }\n\n    return positions;\n}\n\n\n// handles left click\nfunction handleCellClick(cell, minePositions, rows, cols) {\n    if (cell.dataset.isMine === 'true') {\n        // If the cell is a mine\n   ", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "2000:2500"}}
{"text": "itions, rows, cols) {\n    if (cell.dataset.isMine === 'true') {\n        // If the cell is a mine\n        gameOver(minePositions, rows, cols);\n    } else {\n        // If the cell is not a mine, reveal surrounding mines count or expand\n        revealCell(cell, rows, cols, minePositions);\n    }\n}\n\n// handles right click\nfunction handleRightClick(cell) {\n    if (cell.dataset.flagged === 'true') {\n        cell.dataset.flagged = 'false';\n        cell.style.backgroundColor = '';        // reset the cel", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "2400:2900"}}
{"text": "    cell.dataset.flagged = 'false';\n        cell.style.backgroundColor = '';        // reset the cell to the original color specified in CSS file\n        if (cell.dataset.isMine === 'true') {\n            gameState.count1--;    // # of flagged mines decreases by 1\n        }\n    } else {\n        cell.dataset.flagged = 'true';\n        cell.style.backgroundColor = 'yellow';  // change the color to yellow\n        if (cell.dataset.isMine === 'true') {\n            gameState.count1++;    // # of flagged", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "2800:3300"}}
{"text": "low\n        if (cell.dataset.isMine === 'true') {\n            gameState.count1++;    // # of flagged mines increases by 1\n        }\n    }\n    checkWinCondition();\n}\n\n\n\nfunction gameOver(minePositions, rows, cols) {\n    // Reveal all cells\n    document.querySelectorAll('.cell').forEach(cell => {\n        const isMine = cell.dataset.isMine === 'true';\n        cell.style.backgroundColor = isMine ? 'red' : 'white';\n        if (!isMine) {\n            // Optionally, calculate and display the number of ", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "3200:3700"}}
{"text": "d' : 'white';\n        if (!isMine) {\n            // Optionally, calculate and display the number of surrounding mines\n            const count = getSurroundingMineCount(cell, minePositions);\n            cell.textContent = count > 0 ? count : '';\n        }\n    });\n\n    // Show game over message after 3 seconds\n    setTimeout(() => showEndGameMessage(false), 1000);\n}\n\nfunction checkWinCondition() {\n    if (gameState.count1 === gameState.n && gameState.count2 === gameState.rows * gameState.cols - ga", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "3600:4100"}}
{"text": "   if (gameState.count1 === gameState.n && gameState.count2 === gameState.rows * gameState.cols - gameState.n) {\n        setTimeout(() => showEndGameMessage(true), 1000);\n    }\n    \n}\n\n\nfunction getSurroundingMineCount(cell, minePositions) {\n    const row = parseInt(cell.dataset.row, 10);\n    const col = parseInt(cell.dataset.col, 10);\n    let mineCount = 0;\n\n    // Define the relative positions of all possible neighboring cells\n    const neighbors = [\n        [-1, -1], [-1, 0], [-1, 1], // Abov", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "4000:4500"}}
{"text": "f all possible neighboring cells\n    const neighbors = [\n        [-1, -1], [-1, 0], [-1, 1], // Above\n        [0, -1],           [0, 1],  // Sides\n        [1, -1], [1, 0], [1, 1]    // Below\n    ];\n\n    neighbors.forEach(offset => {\n        const neighborRow = row + offset[0];\n        const neighborCol = col + offset[1];\n        const key = `${neighborRow},${neighborCol}`;\n\n        if (minePositions.has(key)) {\n            mineCount++;\n        }\n    });\n\n    return mineCount;\n}\n\n\n\nfunction revea", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "4400:4900"}}
{"text": "ns.has(key)) {\n            mineCount++;\n        }\n    });\n\n    return mineCount;\n}\n\n\n\nfunction revealCell(cell, rows, cols, minePositions) {\n    // Check if the cell has already been revealed to prevent unnecessary work\n    if (cell.dataset.revealed === 'true') {\n        return;\n    }\n\n    // Mark the cell as revealed\n    cell.dataset.revealed = 'true';\n    gameState.count2++;  // # of cells revealed increases by 1\n    checkWinCondition();\n\n    // Calculate the number of surrounding mines\n    co", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "4800:5300"}}
{"text": "led increases by 1\n    checkWinCondition();\n\n    // Calculate the number of surrounding mines\n    const mineCount = getSurroundingMineCount(cell, minePositions);\n    // Change the background color of revealed cells to white\n    cell.style.backgroundColor = 'white';\n\n\n    if (mineCount > 0) {\n        // If there are mines around, show the count and adjust styling as needed\n        cell.textContent = mineCount;\n    } else {\n        // If there are no surrounding mines, proceed to reveal surroundin", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "5200:5700"}}
{"text": "= mineCount;\n    } else {\n        // If there are no surrounding mines, proceed to reveal surrounding cells\n        const row = parseInt(cell.dataset.row, 10);\n        const col = parseInt(cell.dataset.col, 10);\n        const neighborOffsets = [\n            [-1, -1], [-1, 0], [-1, 1], // above\n            [0, -1],           [0, 1],  // side\n            [1, -1], [1, 0], [1, 1]     // below\n        ];\n\n        neighborOffsets.forEach(offset => {\n            const neighborRow = row + offset[0];\n   ", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "5600:6100"}}
{"text": "];\n\n        neighborOffsets.forEach(offset => {\n            const neighborRow = row + offset[0];\n            const neighborCol = col + offset[1];\n            // Ensure we only try to reveal cells within the grid boundaries\n            if (neighborRow >= 0 && neighborRow < rows && neighborCol >= 0 && neighborCol < cols) {\n                const neighborCell = document.querySelector(`.cell[data-row=\"${neighborRow}\"][data-col=\"${neighborCol}\"]`);\n                if (neighborCell && neighborCell.data", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "6000:6500"}}
{"text": "${neighborRow}\"][data-col=\"${neighborCol}\"]`);\n                if (neighborCell && neighborCell.dataset.revealed !== 'true') {\n                    revealCell(neighborCell, rows, cols, minePositions);\n                }\n            }\n        });\n    }\n}\n\nfunction showEndGameMessage(win) {\n    const messageText = win ? \"You win, congratulations!\" : \"You lose.\";\n\n    const messageContainer = document.createElement('div');\n    messageContainer.className = 'message-container';\n    document.body.append", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "6400:6900"}}
{"text": "createElement('div');\n    messageContainer.className = 'message-container';\n    document.body.appendChild(messageContainer);\n\n    const message = document.createElement('div');\n    message.id = 'winMessage';\n    message.textContent = messageText;\n    messageContainer.appendChild(message);\n\n    // Add difficulty buttons\n    const difficulties = [\n        { label: 'Easy', rows: 10, cols: 15, mines: 10 },\n        { label: 'Medium', rows: 15, cols: 20, mines: 40 },\n        { label: 'Hard', rows: 15,", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "6800:7300"}}
{"text": "10 },\n        { label: 'Medium', rows: 15, cols: 20, mines: 40 },\n        { label: 'Hard', rows: 15, cols: 25, mines: 50 }\n    ];\n\n    difficulties.forEach(diff => {\n        const button = document.createElement('button');\n        button.textContent = diff.label;\n        button.className = 'button-style';\n        button.onclick = () => {\n            initializeGameBoard(diff.rows, diff.cols, diff.mines);\n            document.body.removeChild(messageContainer);\n        };\n        messageContainer.", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "7200:7700"}}
{"text": "ines);\n            document.body.removeChild(messageContainer);\n        };\n        messageContainer.appendChild(button);\n    });\n\n    // Add home button\n    const homeButton = document.createElement('button');\n    homeButton.textContent = 'Home';\n    homeButton.className = 'button-style';\n    homeButton.onclick = () => {\n        location.href = 'home.html';\n    };\n    messageContainer.appendChild(homeButton);\n}\n\n", "metadata": {"path": "minesweeper.js", "size": "8016", "chunk_range": "7600:8016"}}
